import { EventEmitter } from 'eventemitter3';
import { v4 as uuidv4 } from 'uuid';
import {
  ActorConfig,
  ActorState,
  ActorContext,
  ActorResult,
  QueryResult,
  Event,
  Command,
  Query,
  Notification,
  EventHandler,
} from './types';
import { MonitoringCapabilities } from './monitoring';
import { SecurityCapabilities, SecurityEvent, SecurityEventData, SecurityEventQuery } from './security';
import { StateManagementHelpers } from './state-management';
import { CircuitBreaker } from './circuit-breaker';
import { RateLimiter, RateLimiterOptions } from './rate-limiter';
import { ComponentExportManager, ComponentExport, ComponentManifest } from './component-exports';
import { EventValidator } from './event-validator';
import { TestUtilities } from './test-utilities';

/**
 * Enhanced Base Actor Class with Built-in Production Features
 * 
 * Features based on learnings from user-auth actor:
 * 1. Built-in monitoring and metrics
 * 2. Security event tracking
 * 3. Rate limiting primitives
 * 4. State management helpers
 * 5. Health checks
 * 6. Event validation
 * 7. Circuit breakers for external calls
 * 8. Standardized error handling
 * 9. Testing utilities
 * 10. Component export management
 */
export abstract class Actor<TState extends ActorState = ActorState> {
  protected state: TState;
  protected context: ActorContext;
  private eventEmitter: EventEmitter;
  private eventHandlers: Map<string, EventHandler[]>;
  
  // Built-in production features
  protected monitoring: MonitoringCapabilities;
  protected security: SecurityCapabilities;
  protected stateHelpers: StateManagementHelpers<TState>;
  protected circuitBreakers: Map<string, CircuitBreaker>;
  protected rateLimiters: Map<string, RateLimiter>;
  protected componentExports: ComponentExportManager;
  protected eventValidator: EventValidator;
  protected testMode: boolean = false;
  
  // Health check data
  private lastHealthCheck: Date;
  private healthStatus: HealthStatus = {
    healthy: true,
    checks: {},
    lastUpdated: new Date(),
  };
  
  // Timers for cleanup
  private timers: NodeJS.Timeout[] = [];

  constructor(context: ActorContext, initialState?: TState) {
    this.context = context;
    this.state = initialState || ({} as TState);
    this.eventEmitter = new EventEmitter();
    this.eventHandlers = new Map();
    this.lastHealthCheck = new Date();
    
    // Initialize built-in capabilities
    this.monitoring = new MonitoringCapabilities(this.config.name);
    this.security = new SecurityCapabilities();
    this.stateHelpers = new StateManagementHelpers<TState>();
    this.circuitBreakers = new Map();
    this.rateLimiters = new Map();
    this.componentExports = new ComponentExportManager();
    this.eventValidator = new EventValidator();
    
    // Set actor info for component exports
    this.componentExports.setActorInfo(this.config.name, this.config.version || '1.0.0');
    
    // Set up periodic health checks
    this.scheduleHealthChecks();
    
    // Set up metrics endpoint if enabled
    if (process.env.ENABLE_METRICS_ENDPOINT === 'true') {
      this.setupMetricsEndpoint();
    }
  }

  get config(): ActorConfig {
    return this.context.config;
  }

  get id(): string {
    return this.context.actorId;
  }

  /**
   * Initialize actor with enhanced features
   */
  async initialize(): Promise<void> {
    this.context.logger.info(`Initializing actor ${this.config.name}`);
    
    const savedState = await this.context.runtime.loadState(this.id);
    if (savedState) {
      this.state = savedState as TState;
    }

    // Initialize monitoring
    await this.monitoring.initialize();
    
    // Call subclass initialization
    await this.onInitialize();
    
    // Register default metrics
    this.registerDefaultMetrics();
    
    // Perform initial health check
    await this.performHealthCheck();
    
    this.context.logger.info(`Actor ${this.config.name} initialized`);
  }

  /**
   * Enhanced command handling with monitoring and validation
   */
  async handle(event: Command): Promise<ActorResult> {
    const startTime = Date.now();
    const correlationId = event.metadata?.correlationId || uuidv4();
    const timer = this.monitoring.startTimer(`command_${event.type}_duration`);
    
    this.context.logger.info(`Handling command ${event.type}`, {
      correlationId,
      payload: event.payload,
    });

    try {
      // Validate event
      const validationResult = await this.eventValidator.validateCommand(event);
      if (!validationResult.valid) {
        this.monitoring.incrementCounter(`command_${event.type}_validation_failed`);
        return {
          success: false,
          error: new Error(`Validation failed: ${validationResult.errors.join(', ')}`),
        };
      }
      
      // Check rate limits if configured
      if (this.rateLimiters.has(event.type)) {
        const rateLimiter = this.rateLimiters.get(event.type)!;
        const allowed = await rateLimiter.allow(event.metadata?.userId || 'anonymous');
        if (!allowed) {
          this.monitoring.incrementCounter(`command_${event.type}_rate_limited`);
          return {
            success: false,
            error: new Error('Rate limit exceeded'),
          };
        }
      }
      
      // Execute command
      const result = await this.onCommand(event);
      
      // Record success metrics
      this.monitoring.incrementCounter(`command_${event.type}_success`);
      
      // Emit events if any (graceful degradation on failure)
      if (result.events && result.events.length > 0) {
        for (const emittedEvent of result.events) {
          try {
            await this.emit(emittedEvent);
          } catch (error) {
            this.context.logger.warn(`Failed to emit event ${emittedEvent.type}`, error as Error);
            // Don't fail the command if event emission fails
          }
        }
      }

      // Save state (graceful degradation on failure)
      try {
        await this.saveState();
      } catch (error) {
        this.context.logger.warn('Failed to save state', error as Error);
        // Don't fail the command if state save fails
      }

      const duration = Date.now() - startTime;
      this.context.logger.info(`Command ${event.type} handled successfully`, {
        correlationId,
        duration,
      });

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.monitoring.incrementCounter(`command_${event.type}_error`);
      
      // Track security events for certain error types
      if (this.isSecurityError(error as Error)) {
        this.trackSecurityEvent({
          type: 'command_security_error',
          severity: 'high',
          details: {
            command: event.type,
            error: (error as Error).message,
          },
        });
      }
      
      this.context.logger.error(`Command ${event.type} failed`, error as Error, {
        correlationId,
        duration,
      });

      return {
        success: false,
        error: error as Error,
      };
    } finally {
      timer();
    }
  }

  /**
   * Enhanced query handling with caching and monitoring
   */
  async query(query: Query): Promise<QueryResult> {
    const startTime = Date.now();
    const correlationId = query.metadata?.correlationId || uuidv4();
    const timer = this.monitoring.startTimer(`query_${query.type}_duration`);
    
    this.context.logger.debug(`Processing query ${query.type}`, {
      correlationId,
      payload: query.payload,
    });

    try {
      // Validate query
      const validationResult = await this.eventValidator.validateQuery(query);
      if (!validationResult.valid) {
        this.monitoring.incrementCounter(`query_${query.type}_validation_failed`);
        return {
          success: false,
          error: new Error(`Validation failed: ${validationResult.errors.join(', ')}`),
        };
      }
      
      const result = await this.onQuery(query);
      
      this.monitoring.incrementCounter(`query_${query.type}_success`);
      
      const duration = Date.now() - startTime;
      this.context.logger.debug(`Query ${query.type} completed`, {
        correlationId,
        duration,
      });

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.monitoring.incrementCounter(`query_${query.type}_error`);
      
      this.context.logger.error(`Query ${query.type} failed`, error as Error, {
        correlationId,
        duration,
      });

      return {
        success: false,
        error: error as Error,
      };
    } finally {
      timer();
    }
  }

  /**
   * Publish notification with monitoring
   */
  async publish(notification: Notification): Promise<void> {
    const enrichedNotification = {
      ...notification,
      metadata: {
        ...notification.metadata,
        source: this.config.name,
        timestamp: Date.now(),
        actorId: this.id,
      },
    };

    await this.context.runtime.publish(enrichedNotification);
    
    this.monitoring.incrementCounter(`notification_${notification.type}_published`);
    
    this.context.logger.debug(`Published notification ${notification.type}`, {
      payload: notification.payload,
    });
  }

  /**
   * Subscribe to events with automatic error handling
   */
  on(eventType: string, handler: EventHandler): void {
    const wrappedHandler = async (event: Event) => {
      const timer = this.monitoring.startTimer(`event_handler_${eventType}_duration`);
      try {
        await handler(event);
        this.monitoring.incrementCounter(`event_handler_${eventType}_success`);
      } catch (error) {
        this.monitoring.incrementCounter(`event_handler_${eventType}_error`);
        this.context.logger.error(`Event handler for ${eventType} failed`, error as Error);
        throw error;
      } finally {
        timer();
      }
    };
    
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, []);
    }
    
    this.eventHandlers.get(eventType)!.push(wrappedHandler);
    this.context.runtime.subscribe(eventType, wrappedHandler);
  }

  /**
   * Enhanced ask pattern with circuit breaker
   */
  protected async ask<T = any>(actorName: string, event: Event): Promise<T> {
    const breaker = this.getOrCreateCircuitBreaker(actorName);
    
    return breaker.execute(async () => {
      const timer = this.monitoring.startTimer(`ask_${actorName}_duration`);
      try {
        const result = await this.context.runtime.ask<T>(actorName, {
          ...event,
          metadata: {
            ...event.metadata,
            source: this.config.name,
            sourceActorId: this.id,
          },
        });
        this.monitoring.incrementCounter(`ask_${actorName}_success`);
        return result;
      } catch (error) {
        this.monitoring.incrementCounter(`ask_${actorName}_error`);
        throw error;
      } finally {
        timer();
      }
    });
  }

  /**
   * Enhanced tell pattern with monitoring
   */
  protected async tell(actorName: string, event: Event): Promise<void> {
    const timer = this.monitoring.startTimer(`tell_${actorName}_duration`);
    try {
      await this.context.runtime.tell(actorName, {
        ...event,
        metadata: {
          ...event.metadata,
          source: this.config.name,
          sourceActorId: this.id,
        },
      });
      this.monitoring.incrementCounter(`tell_${actorName}_success`);
    } catch (error) {
      this.monitoring.incrementCounter(`tell_${actorName}_error`);
      throw error;
    } finally {
      timer();
    }
  }

  /**
   * Emit event with monitoring
   */
  protected async emit(event: Event): Promise<void> {
    const enrichedEvent = {
      ...event,
      metadata: {
        ...event.metadata,
        source: this.config.name,
        sourceActorId: this.id,
        timestamp: Date.now(),
      },
    };

    await this.context.runtime.publish(enrichedEvent);
    this.monitoring.incrementCounter(`event_${event.type}_emitted`);
  }

  /**
   * Save state with retry logic
   */
  protected async saveState(): Promise<void> {
    const breaker = this.getOrCreateCircuitBreaker('state_save');
    
    await breaker.execute(async () => {
      const timer = this.monitoring.startTimer('state_save_duration');
      try {
        await this.context.runtime.saveState(this.id, this.state);
        this.monitoring.incrementCounter('state_save_success');
      } catch (error) {
        this.monitoring.incrementCounter('state_save_error');
        throw error;
      } finally {
        timer();
      }
    });
  }

  /**
   * Get or create a circuit breaker for external calls
   */
  protected getOrCreateCircuitBreaker(name: string): CircuitBreaker {
    if (!this.circuitBreakers.has(name)) {
      this.circuitBreakers.set(name, new CircuitBreaker({
        name,
        failureThreshold: 5,
        resetTimeout: 60000, // 1 minute
        halfOpenRequests: 3,
      }));
    }
    return this.circuitBreakers.get(name)!;
  }

  /**
   * Create a rate limiter for a specific operation
   */
  protected createRateLimiter(name: string, options: RateLimiterOptions): RateLimiter {
    const limiter = new RateLimiter(options);
    this.rateLimiters.set(name, limiter);
    return limiter;
  }

  /**
   * Track a security event
   */
  protected trackSecurityEvent(event: SecurityEventData): void {
    this.security.trackEvent({
      ...event,
      actorId: this.id,
      actorName: this.config.name,
    });
    
    this.monitoring.incrementCounter(`security_event_${event.type}`, {
      severity: event.severity,
    });
  }

  /**
   * Register component export
   */
  protected registerComponentExport(component: ComponentExport): void {
    this.componentExports.register(component);
  }

  /**
   * Get component manifest
   */
  getComponentManifest(): ComponentManifest {
    return this.componentExports.getManifest();
  }

  /**
   * Perform health check
   */
  async performHealthCheck(): Promise<HealthStatus> {
    const checks: HealthCheckResult = {};
    
    // Basic health checks
    checks.state = {
      healthy: this.state !== null && this.state !== undefined,
      message: 'State is initialized',
    };
    
    checks.runtime = {
      healthy: this.context.runtime !== null,
      message: 'Runtime is available',
    };
    
    // Circuit breaker status
    const breakerStatuses: any = {};
    this.circuitBreakers.forEach((breaker, name) => {
      breakerStatuses[name] = breaker.getStatus();
    });
    checks.circuitBreakers = {
      healthy: Object.values(breakerStatuses).every((s: any) => s.state !== 'open'),
      message: `Circuit breakers: ${JSON.stringify(breakerStatuses)}`,
    };
    
    // Custom health checks from subclass
    const customChecks = await this.onHealthCheck();
    Object.assign(checks, customChecks);
    
    // Overall health
    const healthy = Object.values(checks).every(check => check.healthy);
    
    this.healthStatus = {
      healthy,
      checks,
      lastUpdated: new Date(),
    };
    
    this.lastHealthCheck = new Date();
    
    // Update metrics
    this.monitoring.setGauge('health_status', healthy ? 1 : 0);
    
    return this.healthStatus;
  }

  /**
   * Get current health status
   */
  getHealthStatus(): HealthStatus {
    return this.healthStatus;
  }

  /**
   * Get monitoring metrics
   */
  async getMetrics(): Promise<any> {
    return this.monitoring.getMetrics();
  }

  /**
   * Get security events
   */
  getSecurityEvents(options?: SecurityEventQuery): SecurityEvent[] {
    return this.security.getEvents(options);
  }

  /**
   * Enable test mode for testing utilities
   */
  enableTestMode(): void {
    this.testMode = true;
    this.monitoring.enableTestMode();
    this.security.enableTestMode();
  }

  /**
   * Get test utilities (only available in test mode)
   */
  getTestUtilities(): TestUtilities | null {
    if (!this.testMode) {
      return null;
    }
    return new TestUtilities(this);
  }

  /**
   * Schedule periodic health checks
   */
  private scheduleHealthChecks(): void {
    const timer = setInterval(async () => {
      await this.performHealthCheck();
    }, 60000); // Every minute
    this.timers.push(timer);
  }

  /**
   * Setup metrics endpoint
   */
  private setupMetricsEndpoint(): void {
    if (this.context.runtime.registerMetricsHandler) {
      this.context.runtime.registerMetricsHandler(async () => {
        return this.monitoring.getMetrics();
      });
    }
  }

  /**
   * Register default metrics
   */
  private registerDefaultMetrics(): void {
    // Command metrics
    this.monitoring.createCounter('commands_total', 'Total commands processed');
    this.monitoring.createCounter('commands_success', 'Successful commands');
    this.monitoring.createCounter('commands_error', 'Failed commands');
    this.monitoring.createHistogram('command_duration', 'Command processing duration');
    
    // Query metrics
    this.monitoring.createCounter('queries_total', 'Total queries processed');
    this.monitoring.createCounter('queries_success', 'Successful queries');
    this.monitoring.createCounter('queries_error', 'Failed queries');
    this.monitoring.createHistogram('query_duration', 'Query processing duration');
    
    // State metrics
    this.monitoring.createCounter('state_saves_total', 'Total state saves');
    this.monitoring.createCounter('state_saves_error', 'Failed state saves');
    this.monitoring.createHistogram('state_save_duration', 'State save duration');
    
    // Health metrics
    this.monitoring.createGauge('health_status', 'Actor health status (1=healthy, 0=unhealthy)');
    
    // Security metrics
    this.monitoring.createCounter('security_events_total', 'Total security events');
  }

  /**
   * Check if error is security-related
   */
  private isSecurityError(error: Error): boolean {
    const securityKeywords = [
      'unauthorized',
      'forbidden',
      'authentication',
      'permission',
      'access denied',
      'invalid token',
    ];
    
    const message = error.message.toLowerCase();
    return securityKeywords.some(keyword => message.includes(keyword));
  }

  /**
   * Shutdown with cleanup
   */
  async shutdown(): Promise<void> {
    this.context.logger.info(`Shutting down actor ${this.config.name}`);
    
    // Clear all timers
    this.timers.forEach(timer => clearInterval(timer));
    this.timers = [];
    
    // Perform final state save
    try {
      await this.saveState();
    } catch (error) {
      this.context.logger.error('Failed to save state during shutdown', error as Error);
    }
    
    // Export final metrics
    if (process.env.EXPORT_METRICS_ON_SHUTDOWN === 'true') {
      const metrics = await this.monitoring.getMetrics();
      this.context.logger.info('Final metrics', { metrics });
    }
    
    // Export security events
    if (process.env.EXPORT_SECURITY_EVENTS_ON_SHUTDOWN === 'true') {
      const events = this.security.getEvents();
      this.context.logger.info('Security events', { count: events.length });
    }
    
    // Call subclass shutdown
    await this.onShutdown();
    
    // Cleanup
    this.eventHandlers.clear();
    this.eventEmitter.removeAllListeners();
    this.circuitBreakers.forEach(breaker => breaker.reset());
    this.rateLimiters.clear();
    
    this.context.logger.info(`Actor ${this.config.name} shut down`);
  }

  /**
   * Abstract methods to be implemented by subclasses
   */
  protected abstract onInitialize(): Promise<void>;
  protected abstract onCommand(command: Command): Promise<ActorResult>;
  protected abstract onQuery(query: Query): Promise<QueryResult>;
  
  /**
   * Optional methods that can be overridden
   */
  protected async onShutdown(): Promise<void> {
    // Override in subclasses if needed
  }
  
  protected async onHealthCheck(): Promise<HealthCheckResult> {
    // Override in subclasses to add custom health checks
    return {};
  }
}

// Type definitions for enhanced features
interface HealthStatus {
  healthy: boolean;
  checks: HealthCheckResult;
  lastUpdated: Date;
}

interface HealthCheckResult {
  [key: string]: {
    healthy: boolean;
    message: string;
  };
}

